# Julia sets
# Author: Jan Prugarewicz

.data
fileName: 		.asciiz "Julia.bmp"
loadReal:		.asciiz "Enter real part: "
loadImaginary:		.asciiz "Enter imaginary part: "

buffer: 		.space 0x2DEA24
floatPixel:		.float 0.004

floatZero:		.float 0.0
floatFour:		.float 4.0
floatTwo:		.float 2.0
floatMinusTwo:		.float -2.0

#		B	M	size				RSV		offset
#header:	.byte	0x42,	0x4D,	0x2D,	0xEA,	0x24,	0x00,	0x00,	0x00,	0x36,	0x00,	0x00,	0x00
#		HeaderSize			Width				Height
#	.byte	0x28,	0x00,	0x00,	0x00,	0x03,	0xE9,	0x00,	0x00,	0x03,	0xE9,	0x00,	0x00
#		color planes	bits per pixel
#	.byte	0x01,	0x00,	0x18,	0x00

.text

main:
########################################################
# $f1 = 0.0
# $f2 = 4.0
# $f3 = 2.0
# $f4 = -2.0
# $f5 - real value of C
# $f6 - imaginary value of C
# $f7 - actual real value of pixel
# $f8 - actual imaginary value of pixel
# $f9 - actual Re^2
# $f10 - actual Im^2
# $f11 - Re^2+Im^2
# $f13 - value of one pixel (floatPixel)
# $f14 - calculation help (real)
# $f15 - calculation help (imaginary)
# $f16 - 2*actual_Re*actual_Im
# $f17 - actual_Re^2-actual_Im^2

# $t1 - buffer address
# $s1 - algorithm precision
# $t2 - colour counter
# $t3 - algorithm counter


definingheader:
	la $t1,buffer
	or $t4,$zero,$t1
	
	#storing "BM" in ID field
	li $t7, 0x42
	sb $t7,($t4)
	li $t7, 0x4D
	sb $t7,1($t4)
	addiu $t4,$t4,2
	
	#FileSize
	li $t7, 0x24
	sb $t7, ($t4)
	addi $t4, $t4, 1
	li $t7, 0xEA
	sb $t7, ($t4)
	addi $t4, $t4, 1
	li $t7, 0x2D
	sb $t7, ($t4)
	addi $t4, $t4, 6
	
	#storing offset of pixel array
	li $t7, 0x36
	sb $t7, ($t4)
	addiu $t4,$t4,4
	
	#DIB Header
	#Number of bytes in the DIB header (from this point)
	li $t7, 0x28
	sb $t7, ($t4)
	addiu $t4,$t4,4
	
	#width obrazka
	li $t7, 0xE9
	sb $t7, ($t4)
	addi $t1, $t4, 1
	li $t7, 0x03
	sb $t7, ($t4)
	addi $t4, $t4, 3
	
	#width obrazka
	li $t7, 0xE9
	sb $t7, ($t4)
	addi $t1, $t4, 1
	li $t7, 0x03
	sb $t7, ($t4)
	addi $t4, $t4, 3
	
	# Number of color planes being used =1
	li $t7, 0x01
	sb $t7, ($t4)
	addiu $t4,$4,2
	
	# Number of bits per pixel = 24
	li $t7, 0x18
	sb $t7, ($t4)
	# Finished
	
	
registerLoading:
	lwc1 $f1, floatZero			# 0.0
	lwc1 $f2, floatFour			# 4.0
	lwc1 $f3, floatTwo			# 2.0
	lwc1 $f4, floatMinusTwo			# -2.0
	
   	la $a0,loadReal				#loading real value of C
   	li $v0,4
   	syscall
   	
   	li $v0, 6
   	syscall
   	movf.s $f5, $f0
   	
   	la $a0,loadImaginary			#loading imaginary value of C
   	li $v0,4
   	syscall
   	
   	li $v0, 6
   	syscall
   	movf.s $f6, $f0
   	
beforeAlgorithm:
	la $t4,54($t1)
   	li $s1, 32				#precision of algorithm (number of loop iterations)
   	la $t1, buffer
   	li $t2, 0
   	lwc1 $f13, floatPixel
   	lwc1 $f8, floatMinusTwo

forEveryRow:
	lwc1 $f7, floatMinusTwo
	c.le.s $f8, $f3
	bc1f toFile
	
forEveryPixel:
	#c.le.s $f7, $f3
	#bc1f forEveryRow
	add $t2, $zero, $zero
	li $t3, 0
	movf.s $f14, $f7
	movf.s $f15, $f8
	
Algorithm:
	blez $t3, afterAlgorithm
	mul.s $f9,$f14,$f14 #kwadrat czesci rzeczywistej
	mul.s $f10,$f15,$f15 #kwadrat czesci urojonej
	mul.s $f16,$f14,$f15 # nowa wartoœæ urojona
	mul.s $f16,$f15,$f3# przemno¿ona razy 2
	
	sub.s $f17,$f9,$f10 # nowa wartoœæ czêœci rzeczywistej
		
	add.s $f14,$f14,$f5 # dodaj sta³¹ do czêœci rzeczywsitej
	add.s $f15,$f15,$f6 # dodaj sta³¹ do czêœci urojonej

	mul.s $f9,$f14,$f14 # liczenie modu³u
	mul.s $f10,$f15,$f15
	
	add.s $f11,$f9,$f10
	addi  $t2,$t2,1	# inkrementacja koloru
	addiu $t3,$t3,1 # zwiêkszyæ licznik
			
	c.le.s $f11,$f2
	bc1f afterAlgorithm
	
	beq $t3,$s1,afterAlgorithm
	j Algorithm
	
afterAlgorithm:
	sll $t2,$t2,8 			#multiply colour by 8, so that colour is from 0-255
	sb $t2,($t4)
	addi $t4,$t4,3 			#moving iterator 3 bytes right 
	
	add.s $f7,$f7,$f13 		#add 1/250 to imaginary part
	c.lt.s $f7,$f3
	bc1f forEveryPixel

	add.s $f8,$f8,$f13		#add 1/250 to real part
	add $t4,$t4,1 			#padding 
	
	j forEveryRow
	
	
toFile:
	# open file
	la $a0, fileName
	li $a1, 1	
	li $a2, 0	
	li $v0, 13
	syscall
	# save file descriptor
	move $t9, $v0
	# write BMP head
	#li $v0, 15
	#move $a0, $t9
	#la $a1, header
	#li $a2, 54
	#syscall
	# write bitmap data
	li $v0, 15
	move $a0, $t9
	la $a1, buffer
	li $a2, 0x2DEA24
	syscall
	# close file
	li $v0, 16
	move $a0, $t9
	syscall
	
